# protoc-gen-go-gin

protoc-gen-go-gin is a protoc plugin that generates use gin http server code from a proto file.

## Install

```shell
$ go install github.com/trumanwong/protoc-gen-go-gin@latest
```

## Usage

api/app/v1/demo.proto

```proto    
syntax = "proto3";

package api.app.v1;

option go_package = "gin-layout/api/app/v1;v1";
import "google/api/annotations.proto";

service Demo {
	rpc GetDemo (GetDemoRequest) returns (GetDemoReply) {
		option (google.api.http) = {
			get: "/api/demo/:id"
		};
	};
}
message GetDemoRequest {
	uint64 id = 1;
}
message GetDemoReply {}
``` 

```shell
$ protoc.exe --proto_path=. --go_out=paths=source_relative:. \
    --go-grpc_out=paths=source_relative:. \
    --go-gin_out=paths=source_relative:. \
    --openapi_out=paths=source_relative:. \
    api/app/v1/demo.proto
```

output:

```go
// Code generated by protoc-gen-gin-http. DO NOT EDIT.
// versions:
// - protoc-gen-gin-http v1.0.0
// - protoc             v4.24.3
// source: api/app/v1/demo.proto

package v1

import (
	context "context"
	gin "github.com/gin-gonic/gin"
	transport "github.com/trumanwong/gin-transport/transport"
	errors "github.com/trumanwong/gin-transport/transport/errors"
	reflect "reflect"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the gin package it is being compiled against.
var _ = new(context.Context)
var _ = errors.New
var _ = gin.Version
var _ = reflect.ValueOf
var _ = transport.SupportPackageIsVersion1

const OperationDemoGetDemo = "/api.app.v1.Demo/GetDemo"

type DemoHTTPServer interface {
	GetDemo(context.Context, *GetDemoRequest) (*GetDemoReply, error)
}

func RegisterDemoHTTPServer(s *transport.Server, srv DemoHTTPServer) {
	s.AddMethod("GET", "/api/demo/:id", OperationDemoGetDemo, _Demo_GetDemo0_HTTP_Handler(s, srv))
}

func _Demo_GetDemo0_HTTP_Handler(s *transport.Server, srv DemoHTTPServer) func(ctx *gin.Context) {
	return func(ctx *gin.Context) {
		var req GetDemoRequest
		if err := ctx.ShouldBindQuery(&req); err != nil {
			s.ResultError(ctx, err)
			return
		}
		if err := ctx.ShouldBindUri(&req); err != nil {
			s.ResultError(ctx, err)
			return
		}
		if validate := reflect.ValueOf(&req).MethodByName("Validate"); validate.IsValid() {
			if err := validate.Call(nil)[0].Interface(); err != nil {
				s.ResultError(ctx, errors.New(400, "", "validate fail: "+err.(error).Error()))
				return
			}
		}
		reply, err := srv.GetDemo(ctx, &req)
		if err != nil {
			s.ResultError(ctx, err)
			return
		}
		s.Result(ctx, 200, reply)
	}
}
```

## run example

main.go

```go
package main

import (
	"fmt"
	v1 "gin-layout/api/app/v1"
	"github.com/gin-gonic/gin"
	"github.com/trumanwong/gin-transport/transport"
)

func main() {
	engine := gin.New()
	engine.Use(gin.Recovery())
	server := transport.NewServer(engine, []*transport.GroupMiddleware{
		// Middleware for operation
		//{
		//	Middleware: func(ctx *gin.Context) {
		//
		//	},
		//	Operations: []string{v1.OperationDemoGetDemo},
		//},
	}, []string{
		fmt.Sprintf(":%d", 8080),
	})
	v1.RegisterDemoHTTPServer(server, v1.UnimplementedDemoServer{})
	err := server.Run()
	if err != nil {
		panic(err)
	}
}
```

## License

This project is licensed under the MIT License - see the [LICENSE.md](https://github.com/trumanwong/protoc-gen-go-gin/blob/main/LICENSE) file for details.

## Acknowledgements

The following project had particular influence on protoc-gen-go-gin's design.

- [go-kratos/kratos](https://github.com/go-kratos/kratos) is a microservice-oriented governance framework implemented by golang.
- [gin-gonic/gin](https://github.com/gin-gonic/gin) is a web framework written in Go.
